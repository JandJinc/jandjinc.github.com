{"ast":null,"code":"import { resolveComponent as _resolveComponent, createVNode as _createVNode, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from \"vue\";\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_router_view = _resolveComponent(\"router-view\");\n  const _component_v_main = _resolveComponent(\"v-main\");\n  const _component_v_app = _resolveComponent(\"v-app\");\n  return _openBlock(), _createBlock(_component_v_app, null, {\n    default: _withCtx(() => [_createVNode(_component_v_main, null, {\n      default: _withCtx(() => [_createVNode(_component_router_view)]),\n      _: 1 /* STABLE */\n    })]),\n\n    _: 1 /* STABLE */\n  });\n}","map":{"version":3,"mappings":";;;;;uBACIA,aAKQC;sBAJJ,MAGS,CAHTC,aAGSC;wBADL,MAAc,CAAdD,aAAcE","names":["_createBlock","_component_v_app","_createVNode","_component_v_main","_component_router_view"],"sourceRoot":"","sources":["C:\\Users\\joost\\Desktop\\code\\informatica\\kunstmatigeintelligentie\\src\\App.vue"],"sourcesContent":["<template>\n    <v-app >\n        <v-main>\n\n            <router-view/>\n        </v-main>\n    </v-app>\n</template>\n\n<script>\n\n// Define an object that will be used to draw plus signs\nvar Plus = function() {\n  this.x = 0;\n  this.y = 0;\n\n  this.top = 0;\n  this.left = 0;\n\n  this.height = 0;\n  this.width = 0;\n  this.scale = 1;\n};\n\n//Add draw method to the object\nPlus.prototype.draw = function(ctx, x, y) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.setTransform(\n    this.scale,\n    0,\n    0,\n    this.scale,\n    this.left + this.x,\n    this.top + this.y\n  );\n  ctx.lineWidth = 2;\n\n  ctx.moveTo(0, -this.height / 2);\n  ctx.lineTo(0, this.height / 2);\n\n  ctx.moveTo(-this.width / 2, 0);\n  ctx.lineTo(this.width / 2, 0);\n\n  ctx.stroke();\n  ctx.closePath();\n  ctx.restore();\n};\n\nvar c = document.getElementById(\"c\");\nvar context = c.getContext(\"2d\");\nvar signs = [];\nvar mouse = { x: 0, y: 0 };\nvar gridLength = 9;\nvar mouseOver = false;\nvar mouseMoved = false;\n\nc.width = window.innerWidth;\nc.height = window.innerHeight;\n\n// Create sign grid using 2D array\nfor (var i = 0; i < gridLength; i++) {\n  signs[i] = [];\n  for (var j = 0; j < gridLength; j++) {\n    var min = Math.min(c.width, c.height);\n    signs[i][j] = new Plus();\n    signs[i][j].left = c.width / (gridLength + 1) * (i + 1);\n    signs[i][j].top = c.height / (gridLength + 1) * (j + 1);\n    signs[i][j].width = min / 50;\n    signs[i][j].height = min / 50;\n  }\n}\n\n// Use GSAP ticker to call draw function on every frame that will draw signs to the canvas\n// You can use requestAnimationFrame as well\nTweenLite.ticker.addEventListener(\"tick\", draw);\n\nfunction draw() {\n  context.clearRect(0, 0, c.width, c.height);\n\n  if (mouseOver && mouseMoved) {\n    calculateSigns();\n    mouseMoved = false;\n  }\n\n  for (var i = 0; i < gridLength; i++) {\n    for (var j = 0; j < gridLength; j++) {\n      var sign = signs[i][j];\n      sign.draw(context);\n    }\n  }\n}\n\nfunction calculateSigns() {\n  for (var i = 0; i < gridLength; i++) {\n    for (var j = 0; j < gridLength; j++) {\n      var sign = signs[i][j];\n      var hyp = Math.min(c.width, c.height) / (gridLength + 1) / 2;\n      var d = dist([sign.left, sign.top], [mouse.x, mouse.y]);\n      var ax = mouse.x - sign.left;\n      var ay = mouse.y - sign.top;\n      var angle = Math.atan2(ay, ax);\n      if (d < hyp + sign.width) {\n        hyp = d;\n        TweenMax.to(sign, 0.3, { scale: 2 });\n      } else {\n        TweenMax.to(sign, 0.3, { scale: 1 });\n      }\n\n      TweenMax.to(sign, 0.3, {\n        x: Math.cos(angle) * hyp,\n        y: Math.sin(angle) * hyp\n      });\n    }\n  }\n}\n\nc.addEventListener(\"mousemove\", mouseMove);\nc.addEventListener(\"touchmove\", mouseMove);\n\nfunction mouseMove(e) {\n  if (e.targetTouches && e.targetTouches[0]) {\n    e = e.targetTouches[0];\n  }\n  var rect = c.getBoundingClientRect();\n  mouse.x = e.clientX - rect.left;\n  mouse.y = e.clientY - rect.top;\n  mouseMoved = true;\n}\n\nc.addEventListener(\"mouseenter\", function() {\n  mouseOver = true;\n});\n\nc.addEventListener(\"touchstart\", function(e) {\n  mouseOver = true;\n  mouseMove(e);\n});\n\nc.addEventListener(\"mouseleave\", mouseLeave);\nc.addEventListener(\"touchend\", mouseLeave);\n\nfunction mouseLeave() {\n  mouseOver = false;\n\n  for (var i = 0; i < gridLength; i++) {\n    for (var j = 0; j < gridLength; j++) {\n      var sign = signs[i][j];\n      if (!mouseOver) {\n        TweenMax.to(sign, 0.3, { x: 0, y: 0, scale: 1 });\n      }\n    }\n  }\n}\n\nwindow.addEventListener(\"resize\", function() {\n  c.width = window.innerWidth;\n  c.height = window.innerHeight;\n  for (var i = 0; i < gridLength; i++) {\n    for (var j = 0; j < gridLength; j++) {\n      var min = Math.min(c.width, c.height);\n      sign = signs[i][j];\n      sign.left = c.width / (gridLength + 1) * (i + 1);\n      sign.top = c.height / (gridLength + 1) * (j + 1);\n      sign.width = min / 50;\n      sign.height = min / 50;\n    }\n  }\n});\n\nfunction dist([x1, y1], [x2, y2]) {\n  var dx = x1 - x2;\n  var dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy) || 1;\n}\n\n\nexport default {\n  name: 'App',\n\n  data: () => ({\n    //\n  }),\n}\n</script>\n"]},"metadata":{},"sourceType":"module"}